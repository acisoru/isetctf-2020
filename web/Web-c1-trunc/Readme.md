# short_book

## Условие
>
> **Записки сисадмина:** *день первый*
>
> На новой работе все должно быть новое! Завел новый ежедневник, купил новую зарядку для айфона. Новым заданием стало создание сайта авторизации для клиентов нашего банка, вот [тут](http://ваш_сайт) набросал на коленке, раньше заходил постоянно из консоли, решил **имя пользователя** не менять. Так как работаю еще на **7070** работах, веду таблицу доходов/расходов, но **колонки постоянно путаются, усекаются,** пока не могу ничего с этим сделать..
> 
> P.S. Если при переходе по ссылке сайт не работает -- все нормально, он работает, try harder =).

## Решение 1

При попытке подключения к серверу ничего не получается. Посмотрим, не оставил ли автор таска подсказку в описании. Видим что-то про **7070**, похоже на порт, заходим -- так и есть.

Видим `login` `reg`, все просто и понятно, на коленке же написано =)

Регаемся как `qwerty` `123`, логинимся, приходит в ответ `Hello, user`.

Понятно, что надо зарегаться как `admin` или `root`, в описании таска *раньше заходил постоянно из консоли, решил имя пользователя не менять*, а значит, что остается `root`.

Зарегаться как `root` не получилось, смотрим еще раз задание. *short_book* и **колонки** при несложном поиске в гугле дают название уязвимости -- **Column Truncation**.

Регаемся как `root      123` и своим паролем.    (`root[6 пробелов]123`)

Что теперь происходит в базе данных серверной части? По умолчанию MySQL обрезает строки, длина которых превышает заданную максимальную ширину столбца, и выдает только предупреждение. Но эти предупреждения обычно видны только в серверной базе данных, а не в веб-приложениях, и поэтому не обрабатываются вообще. MySQL не сравнивает строки в двоичном режиме. По умолчанию используются более мягкие правила сравнения. Одно из таких смягчений - игнорирование конечных пробелов при сравнении. Это означает, что строка `root       ` по-прежнему равна строке `root` в базе данных. И поэтому приложение откажется принять нового пользователя. Если злоумышленник предоставляет `root           123321`, а приложение выполняет поиск этого пользователя в базе данных и не может его найти, поскольку имя столбца имени пользователя ограничено 10 символами, а злоумышленник предоставил 11 символ, приложение примет новое имя пользователя и вставит его в базу данных. Из-за длины столбца в 10 символов приложение усечет имя пользователя и вставит его как `root`. Теперь таблица содержит двух пользователей с правами администратора: `root` и `root`.

Теперь мы пытаемся войти в систему как `root` своим паролем и Bo0oM! ПОлучаем флаг!

## Решение 2

> решил **имя пользователя** не менять

Раз сисадмин такой ленивый, что юзает рута, а не другого пользователя, имеет смысл проверить комбинации:
`root:root`
`root:toor`

Первая выдает флаг.

**Флаг:**

> iset{K0LUmn_TRUNc4t10N_1z_4W350m3}
